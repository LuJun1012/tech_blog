# sync.Map
#### 并发安全字典对键的类型有要求吗
* 有要求。键的实际类型不能是函数类型、字典类型和切片类型
* 由于这些键值的实际类型只有在程序运行期间才能够确定，所以 Go 语言编译器是无法在编译期对它们进行检查的，不正确的键值实际类型肯定会引发 panic
* 应该在每次操作并发安全字典的时候，都去显式地检查键值的实际类型。无论是存、取还是删，都应该如此。

#### 使用sync.map
```
type IntStrMap struct {
 m sync.Map
}
func (iMap *IntStrMap) Range(f func(key int, value string) bool) {
 f1 := func(key, value interface{}) bool {
  return f(key.(int), value.(string))
 }
 iMap.m.Range(f1)
}
```
#### 怎样保证并发安全字典中的键和值的类型正确性？
* 通过封装sync.map，添加reflect.Type来判断key和value来使用

#### 并发字典如何做到尽量避免安全锁
* 使用大量原子操作来读取键和值
* 这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。
* 只读字典和脏字典之间是会互相转换的。在脏字典中查找键值对次数足够多的时候，sync.Map会把脏字典直接作为只读字典，保存在它的read字段中，然后把代表脏字典的dirty字段的值置为nil。
* 读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。
* 性能影响 新增键值对 > 删除 > 修改

#### sync.Map修改value
* 只读字典虽然不会增减其中的键，但却允许变更其中的键所对应的值。所以，它并不是传统意义上的快照，它的只读特性只是对于其中键的集合而言的。
* 