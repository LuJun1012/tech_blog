# 原子操作
#### CAS的使用场景
* 共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，或者说更加宽松的做法。

#### 原子锁和互斥锁的三个决策条件
* 变量类型 原子值中不要存储引用的类型，容易造成安全漏洞
* 操作频率
* 操作时间

#### atomic.Value
* 复制该类型的值会产生一个完全分离的新值。这个新值相当于被复制的那个值的一个快照。
* 它的动态值是nil，但动态类型却不是nil，那么它的值就不等于nil,可以被存储原子值
* 我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。

#### 使用注意事项
* 不要把内部使用的原子值暴露给外界。比如，声明一个全局的原子变量并不是一个正确的做法。这个变量的访问权限最起码也应该是包级私有的。
* 如果不得不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数，让外界间接地使用到它。注意，这种情况下不要把原子值传递到外界，不论是传递原子值本身还是它的指针值。
* 如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性。若不合法，则应该直接返回对应的错误值，从而避免 panic 的发生。
* 如果可能的话，我们可以把原子值封装到一个数据类型中，比如一个结构体类型。这样，我们既可以通过该类型的方法更加安全地存储值，又可以在该类型中包含可存储值的合法类型信息。