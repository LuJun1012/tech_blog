# Linux性能答疑
#### 内存回收方式
* 基于 LRU（Least Recently Used）算法，回收缓存；
* 基于 Swap 机制，回收不常访问的匿名页；
* 基于 OOM（Out of Memory）机制，杀掉占用大量内存的进程。触发时机是进程在申请内存时，如果申请的虚拟内存加上服务器实际已用的内存之和，比总的物理内存还大，就会触发OOM

#### 统计总内存
* 把共享内存平分到各个进程后，再加上进程本身的非共享内存大小的和。
* grep Pss /proc/[1-9]*/smaps | awk '{total+=$2}; END {printf "%d kB\n", total }'

#### 缓存和缓冲区的却别
* 缓存包括两部分，一部分是磁盘读取文件的页缓存，用来缓存从磁盘读取的数据，可以加快以后再次访问的速度。另一部分，则是 Slab 分配器中的可回收内存。
* 缓冲区是对原始磁盘块的临时存储，用来缓存将要写入磁盘的数据。这样，内核就可以把分散的写集中起来，统一优化磁盘写入。

#### 各种内存片段
* 虚拟内存，包括了进程代码段、数据段、共享内存、已经申请的堆内存和已经换出的内存等。这里要注意，已经申请的内存，即使还没有分配物理内存，也算作虚拟内存。
* 常驻内存是进程实际使用的物理内存，不过，它不包括 Swap 和共享内存。
* 共享内存，既包括与其他进程共同使用的真实的共享内存，还包括了加载的动态链接库以及程序的代码段等。
* ![e28cf90f0b137574bca170984d1e6736](media/15470904831321/e28cf90f0b137574bca170984d1e6736.png)

#### 内存性能工具
* 根据指标找工具
* ![8f477035fc4348a1f80bde3117a7dfed](media/15470904831321/8f477035fc4348a1f80bde3117a7dfed.png)
* 工具工具找指标
![52bb55fba133401889206d02c224769b](media/15470904831321/52bb55fba133401889206d02c224769b.png)
* 分析流程图
![d79cd017f0c90b84a36e70a3c5dccffe](media/15470904831321/d79cd017f0c90b84a36e70a3c5dccffe.png)

#### 内存优化思路
* 最好禁止 Swap。如果必须开启 Swap，降低 swappiness 的值，减少内存回收时 Swap 的使用倾向。
* 减少内存的动态分配。比如，可以使用内存池、大页（HugePage）等。
* 尽量使用缓存和缓冲区来访问数据。比如，可以使用堆栈明确声明内存空间，来存储需要缓存的数据；或者用 Redis 这类的外部缓存组件，优化数据的访问。
* 使用 cgroups 等方式限制进程的内存使用情况。这样，可以确保系统内存不会被异常进程耗尽。
* 通过 /proc/pid/oom_adj ，调整核心应用的 oom_score。这样，可以保证即使内存紧张，核心应用也不会被 OOM 杀死。


