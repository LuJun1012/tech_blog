# 工业级别散列表

#### 散列表碰撞攻击
* 使得所有的数据经过散列函数之后，都散列到同一个槽里

####  散列函数设计
* 散列函数的设计不能太复杂
* 散列函数生成的值要尽可能随机并且均匀分布

#### 避免动态扩容
* 当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了
* 查询的时候先去老的散列表查询，再去新的散列表查询

#### 决绝冲突

##### 开放寻址法
* 所有数据都在一个数组里，冲突的代价高

##### 链表法
* 链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好
* 将链表改造成跳表或者红黑树O(logn)
* 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表

#### HashMap
* 为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树

#### 如何设计散列表
* 设计一个合适的散列函数；
* 定义装载因子阈值，并且设计动态扩容策略；
* 选择合适的散列冲突解决方法。