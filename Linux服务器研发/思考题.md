# 思考题

####  案例、服务器端高并发IO的keep alive方案，满足一下几个需求
* 1. 每个IO都是自己的时间戳
* 2. 每个IO收到自己的beat后，重置自己的定时器
* 3. 若IO定时没有收到beat，则执行IO的回调函数，并重置定时器
* 4. 若再次没有收到beat，销毁IO，注销定时器。

##### 方案一
* timerfd+epoll
* 0. 时间精准度高
* 小块代码逻辑清晰
* 程序总体逻辑混乱
* 代码是基于时间反应堆的
* 回调函数中不易做较长时间操作，比如数椐库，第三方 HTP 请求中

##### 方案三
* 红黑树
* key 时间戳 val 是 io
* 期限到了直接删除节点
* 如果key的值是一样的，从s扩充到ms
* 